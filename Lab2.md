# Лабораторная работа №2

## Цель

Изучение способов управления портами ввода-вывода. Настройка портов в режим ввода. Подключение кнопки.

## Оборудование

1. Миниблок микроконтроллера AT90USB162
2. Вспомогательный миниблок с четырьмя светодиодами
3. Вспомогательный миниблок с семисегментным светодиодным индикатором
4. Провода соединительные
5. Кабель USB - miniUSB
6. Блок БИЦУ (наборное поле с источником питания)
7. ПК с ОС GNU/Linux Ubuntu

## Теоретические сведения

### Подтягивающий резистор

Подтягивающий (Pull-up) резистор - резистор, включенный между сигнальным проводником и шиной питания. Подтягивающий резистор образует цепь, обеспечивающую подтяжку сигнала к питанию.

Подтягивающий резистор нужен, чтобы гарантировать на логическом входе, к которому он подключен, высокий уровень. Иначе говоря подтягивающий  резистор используется, чтобы сделать "состояние по умолчанию" цифрового вывода высоким, то есть лог. 1.

Делать это нужно по следующим причинам:

 - проводник не соединен с логическим выходом;
 - присоединённый логический выход находится в высокоимпедансном состоянии (Hi-Z);
 - когда разомкнут ключевой элемент на присоединённом логическом выходе, который устроен, как открытый вывод ключевого элемента. Ключевым элементом может быть полевой или биполярный транзистор, а открытым выводом — коллектор, эммитер, сток или исток.

Подтягивающий резистор подтягивает неопределенный потенциал ко входу с напряжением 5В, делая его определенным - лог. 1. При нажатии кнопки на пине 1 будет значение лог. 0:

![Pull Up Resistor](/img/pull_up_resistor.png)

### Подключение кнопки ко входу микроконтроллера

Подключение кнопки ко входу микроконтроллера показано на схеме выше. При разомкнутых контактах  кнопки SA1 на входе PB0 будет ВЫСОКИЙ уровень (лог.1). При нажатии на кнопку вывод PB0 соединяется с «землей» (GND), и на входе устанавливается НИЗКИЙ уровень (лог.0). Подтягивающий резистор R1 исключает короткое замыкание с плюса питания на землю при нажатии кнопку.

Кроме того на линиях ввода портов микроконтроллеров AVR установлены внутренние подтягивающие резисторы, которые можно включить путём записи единицы в определенный бит регистра `PORTx`.

Для того чтобы считывать состояние вывода PB0 необходимо предварительно настроить его на вход:

```C
// Чтобы подключить внутренний подтягивающий резистор, линия должна быть настроена на вход
DDRB &= ~(1 << PB0); // Настройка вывода PB0 на вход
PORTB |= (1 << PB0); // Подключение внетреннего подтягивающего резистора вывода PB0
```

Для чтения состояния сигнала на контактах порта используется регистр `PINx`:

```C
// Проверка бита PB0
if ((PINB & (1 << PB0)) == 0)
{
	// Кнопка нажата
}
else
{
	// Кнопка не нажата
}
```


## Ход работы

1. Подключите блок БИЦУ к источнику питания
2. Подключите миниблок с микроконроллером AT90USB162 к компьютеру, используя кабель miniUSB
3. Установите миниблок с микроконроллером AT90USB162 на наборное поле блока БИЦУ
4. Соберите схему в соответствии с рекомендуемой схемой соединений
5. В программе Geany создайте новый проект

Подключить кнопку к выводу PD5 микроконтроллера, а светодиод - к PD0 как показано на рисунке ниже:

![Lab 2 scheme](/img/lab2.png)

Листинг 2.1:

```C
#define F_CPU 8000000UL // Директива установки частоты процессора

#include <avr/io.h> // Библиотека для работы с портами ввода-вывода
#include <util/delay.h> // Библиотека для работы с временной задержкой

int main ()
{
    DDRD |=  (1 << PD0); // Настройка вывода PD0 на выход
    DDRD &= ~(1 << PD5); // Настройка вывода PD5 на вход

    // Включаем внутренний подтягивающий резистор на выводе PD5
    PORTD |=  (1 << PD5);

    // Главный цикл работы МК
    while (1)
    {
        // Проверка бита PD5
        if ((PIND & (1 << PD5)) == 0)
        {
            // Кнопка нажата. На выводе PD5 отсутствует напряжение
            // Выполнение каких-либо действий
            // Например: включение напряжения на выводе PD0
            PORTD |=  (1 << PD0);
        } else
        {
            // Кнопка отжата. На вывод PD5 поступило напряжение
            // Выполнение каких-либо действий
            // Например: отключение напряжения на выводе PD0
            PORTD &= ~(1 << PD0);
        }
    }
}
```

Листинг 2.2. Подсчет количества нажатий на кнопку:

```C
#define F_CPU 8000000UL // Директива устновки частоты процессора
#include <avr/io.h> // Библиотека для работы с портами ввода-вывода
#include <util/delay.h> // Библиотека для работы с паузой

int main ()
{
    DDRD |=  (1 << PD0); // Настройка вывода PD0 на выход
    DDRD &= ~(1 << PD5); // Настройка вывода PD5 на вход

    PORTD &= ~(1 << PD0); // Отключение напряжения на выводе PD0
    PORTD |=  (1 << PD5); // Активация подтягивающего к напряжению питания (pull-up) резистора

    uint8_t btn_click_counter = 0; // Счетчик нажатий
    uint8_t btn_ticks_counter = 0; // Счетчик тиков удержания кнопки
    // Главный цикл работы МК
    while (1)
    {
		// Проверка бита PD5
		if ((PIND & (1 << PD5)) == 0)
		{
			_delay_ms(10); // Короткая пауза для стабилизации
			if (btn_ticks_counter == 0)
			{
				btn_click_counter++; // Увеличиваем на 1 счетчик нажатий
			}
			// Увеличиваем счетчик тиков, пока он не станет равен 10
			if (btn_ticks_counter < 10)
			{
				btn_ticks_counter++; // Увеличиваем на 1 счетчик тиков
			}
		} else
		{
			btn_ticks_counter = 0; // Обнуление счетчика тиков
		}
		// Определение количества нажатий
		if (btn_click_counter == 2)
		{
			// Выполнение действия, если нажали 2 раза
			// Например: включение напряжения на выводе PD0
			PORTD |=  (1 << PD0);
		} else if (btn_click_counter == 4)
		{
			// Выполнение действия, если нажали 4 раза
			// Отключение напряжения на выводе PD0
			PORTD &= ~(1 << PD0);
			// Обнуление счетчика нажатий
			btn_click_counter = 0;
		}
	}
}
```

Скомпилировать полученный код (см. [Компиляция](Software.md#компиляция-программ-на-языке-c) или с помощью [Makefile](Software.md#make-и-makefile)).

Перевести микроконтроллер в режим программирования: одновременно нажать кнопки "СБРОС" и "ПРОГ", отпустить "СБРОС", затем отпустить "ПРОГ". Микроконтроллер перейдет в режим программирования (DFU) и будет ожидать прошивку.

Выполнить загрузку программы в микроконтроллер (см. [Прошивка](Software.md#прошивка-микроконтроллера) или с помощью [Makefile](Software.md#make-и-makefile)).

Нажать кнопку "СБРОС", микроконтроллер перейдет в рабочий режим.

## Задания для самостоятельной работы

1. Собрать схему и написать программу, реализующие «Бинарный счетчик нажатий».
2. Собрать схему и написать программу, реализующие «Повторитель». Светодиод   должен   гореть   столько   тактов,   сколько   была   нажата кнопка.
3. Собрать схему и написать программу, реализующие «Переключатель». По   нажатию   на   кнопку   должен   загораться   следующий   светодиод   в линейке.
4. Собрать схему и написать программу, реализующие «Переключатель+». Схема должна содержать кнопку и переключатель. При одном положении переключателя при нажатии кнопки должен загоратьтся следующий светодиод, а при другом положении переключателя - предыдущий
5. Собрать схему и написать программу, реализующие «Переключатель режимов».   По   первому   нажатию   на   кнопку   должен   загораться светодиод, по второму нажатию он должен мигать 1 раз в секунду, по третьему выключиться.

## Содержание отчета

1. Титульный лист
2. Цель, задание на лабораторную работу
3. Электрическая схема
4. Алгоритм работы
5. Заключение
6. Приложения

## Контрольные вопросы

1. Как перевести вывод порта в режим входа?
2. Что такое pull-up резистор? Где он? Как его активировать?
3. В каком регистре хранится текущее состояние порта? Как его считать?
4. Как притормозить МК, поставить на паузу?
5. Как однозначно идентифицировать нажатие на кнопку и отсеять помехи?
