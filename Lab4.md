# Программирование аналого-цифрового преобразователя (АЦП) микроконтроллера

## Цель

Познакомиться с работой АЦП микроконтроллера.

## Оборудование

1. Миниблок микроконтроллера ATmega16
2. Вспомогательный миниблок с переменным резистором на 10 кОм
3. Два вспомогательных миниблока с семисегментным светодиодным индикатором
4. Провода соединительные
5. Кабель USB - miniUSB
6. Блок БИЦУ (наборное поле с источником питания)
7. ПК с ОС GNU/Linux Ubuntu

## Теоретические сведения

### Общие сведения об АЦП

Порты ввода/вывода микроконтроллера в общем случае могут "воспринимать" только цифровые сигналы - лог. 0 или лог. 1. Довольно часто возникает необходимость измерять аналоговые сигналы, которые могут принимать любые значения в заданном диапазоне. Для этих целей в составе микроконтроллеров AVR есть аналого-цифровой преобразователь (АЦП).

На вход АЦП подается непрерывный аналоговый сигнал, а на выходе получается цифровой код, пропорциональный измеренной величине.

Типы АЦП:

 - АЦП параллельного (прямого) преобразования (flash ADC);
 - АЦП последовательного приближения (SAR ADC);
 - дельта-сигма АЦП.
 - и др.

Основные характеристики АЦП:

 - разрешающая способность;
 - абсолютная точность;
 - предельная частота дискретизации;
 - диапазон входных напряжений.

 **Разрешающая способность (разрешение)** – это способность АЦП различать два значения входного сигнала. Определяется как величина обратная максимальному числу кодовых комбинаций на выходе АЦП. У микроконтроллеров AVR АЦП 10-ти разрядный. Максимальное число кодовых комбинаций будет равно 2^10 = 1024. Разрешающая способность равна 1/1024 от всей шкалы допустимых входных напряжений.
 
Для работы АЦП необходим источник опорного напряжения (ИОН). Для него это эталон, по отношению к которому он измеряет входные сигналы. 

> [!NOTE]  
> **Источник опорного напряжения (ИОН)** - элемент, на выходе которого поддерживается высокостабильное постоянное напряжение заданной величины.

Микроконтроллеры AVR позволяют в качестве ИОНа использовать
 - напряжение питания, 
 - внутренний опорный источник;
 - напряжение на выводе AREF (внешний ИОН).

Если напряжение питания в схеме 5 В, тогда 1/1024 от всей шкалы это 5×(1/1024) = 0,0048 В или примерно 5 мВ. С таким шагом (это называется **шаг квантования**) АЦП будет измерять входное напряжение. Если два ближайших значения сигнала на входе АЦП будут отличаться между собой на величину < 5 мВ, АЦП воспримет их как одинаковые. На практике разрешающая способность АЦП ограничена его шумами.

**Абсолютная точность** – отклонение реального преобразования от идеального. Это составной результат нескольких погрешностей АЦП. Выражается в количестве младших значащих разрядов (LSB - least significant bit) АЦП. Для AVRа абсолютная погрешность АЦП = ±2LSB. Для нашего примера абсолютная точность будет равна 2 * 5 мВ = ±10 мВ.

**Предельная частота дискретизации** определяет быстродействие АЦП и измеряется в герцах или количестве выборок в секунду (SPS – samples per second). Для микроконтроллеров AVR эта величина равна 15 kSPS (килло семплов в секунду). Практически АЦП AVRа работает и быстрее, но при этом  его точность ухудшается.

> [!NOTE]  
> **Теорема Котельникова (теорема Найквиста-Шеннона, теорема о выборке)** гласит, что аналоговый сигнал имеющий ограниченный спектр, может быть восстановлен однозначно и без потерь по своим дискретным отсчётам, если частота выборки (дискретизации) превышает максимальную частоту спектра сигнала более чем в 2 раза.

Выражаясь по-простому - если вам нужно оцифровать аналоговый сигнал с полосой спектра 0 - 7 кГц, то в идеальном случае частота дискретизации должна быть больше удвоенной максимальной частоты спектра этого сигнала, то есть больше 14 кГц. На практике все намного сложнее. Перед входом АЦП всегда ставят НЧ фильтр, чтобы ограничить спектр сигнала, а частота дискретизации выбирается еще более высокой.

**Диапазон входных напряжений** – это минимальное и максимальное значение напряжения, которое можно подавать на вход АЦП. Для микроконтроллера AVR он равен 0...Vcc (напряжение питания). Этому диапазону соответствует интервал диапазон кодов АЦП от 0 до 1023 соответственно.

Если сравнить АЦП с линейкой, то минимальное и максимальное значение шкалы - диапазон входных напряжений, количество делений линейки – число кодовых комбинаций (число уровней квантования), расстояние между двумя соседними делениями  - шаг квантования, а шаг квантования деленный на диапазон входных напряжений – разрешающая способность.


### Регистры АЦП в AVR

В AVR для настройки АЦП нужно знать четыре основных регистра:

 - `ADCH`: содержит старший байт результата преобразования АЦП;
 - `ADCL`: содержит младший байт результата преобразования АЦП;
 - `ADMUX`: регистр выбора мультиплексора АЦП;
 - `ADCSRA`: регистр управления и состояния АЦП.

> [!NOTE]  
> При программировании на языке C результат преобразования АЦП может быть получен из регистра `ADC`. Компилятор сам преобразует два 8-битных регистра `ADCL` и `ADCH` в один 16-битный `ADC`, в котором будет находится 10-битный результат преобразования.


### Пошаговая инструкция использования АЦП в AVR

 - Укажите входной канал АЦП.
 - Установите бит включения `ADEN` в `ADCSRA`, выберите скорость преобразования с помощью `ADPS2:0`.
 - Далее необходимо выбрать один из трех вариантов опорного напряжения, используя `REFS1:REFS0` в регистре `ADMUX`.
 - Выберите входной канал АЦП, используя `MUX4:0` в `ADMUX`, 
 - Начните преобразование, установив бит `ADSC` в `ADCSRA`. Например, `ADCSRA |= (1<<ADSC)`.
 - Дождитесь завершения преобразования. Для этого необходимо опрашивать `ADIF`. Бит установиться в единицу после завершения преобразования. Данный бит содержится в регистре `ADCSRA`.
 - После того, как бит `ADIF` станет равным единице, необходимо считать содержимое регистров `ADCL` и `ADCH`, чтобы получить цифровое значение преобразования.

## Ход работы

1. Изучить принципы работы с АЦП микроконтроллера ATmega16u4.
2. Собрать на стенде схему по рис. 4.1 из [Руководства по выполнению базовых экспериментов](/extra/920.5.pdf).
3. Загрузить программу по листингу 4.1 в микроконтроллер ATmega16u4.
4. Снимите данные, получаемые с помощью АЦП, заполнив таблицу 4.2 (из [Руководства по выполнению базовых экспериментов](/extra/920.5.pdf)). Измерение входного напряжения Uвх производите с помощью мультиметра.


Листинг 4.1. АЦП при вводе данных не дифференциального сигнала

```C
/* Exp_4 "Программирование АЦП микроконтроллера"
 * Exp_4_1 "Программирование АЦП при вводе данных недифференциального сигнала" 
 * АЦП микроконтроллера программируется для ввода данных по каналу ADC0 (вывод PF0)
 * c движка потенциометра A5, выполняющего роль линейного регулятора. Микроконтроллер 
 * пересчитывает полученный результат в Вольты и выводит полученный результат на 
 * семисегментный индикатор. Мультиметр позволяет судить о правильности полученного
 * результата.
 * Тумблер SA2 задает выравнивание полученного результата АЦП:
 * "0" - правое выравнивание результата;
 * "1" - левое выравнивание результата.
 * Тумблер SA3 задает величину опорного напряжения
 * "0"- опорное напряжение микроконтроллера равно напряжению питания микроконтроллера на
 *		выводе AVcc;
 * "1" - опорное напряжение равно 2.56 В.
 */ 

#include <avr/io.h>

#define K_V_R_256 40	//коэффициент приведения результата к В*10 при при правом
//выравнивании и опорном напряжении 2.56 В
#define K_V_L_256 2560	//коэффициент приведения результата к В*10 при при левом
//выравнивании и опорном напряжении 2.56 В 
#define K_V_R_500 20		//коэффициент приведения результата к В*10 при при правом
//выравнивании и опорном напряжении 5 В (напряжение питания)
#define K_V_L_500 1310	//коэффициент приведения результата к В*10 при при левом
//выравнивании и опорном напряжении 5 В (напряжение питания)	

//программа преобразует число к двоично-десятичному числу, упакованному в один байт
//n – преобразуемое число (в диапазоне от 0…99
//выход: двоично-десятичное число
unsigned char PrintBCD99(unsigned char n)
{
	unsigned char nl;			//младшая тетрада двоично-десятичного числа
	nl=n%10;
	n=n/10;
	n=(n<<4)+nl;
	return n;
}

int main(void)
{
	DDRB=0xff;		//выводы управления семисегментным индикатором работают на выход
	DDRD|=(1<<PD3);	//выход управления точкой семисегментного индикатора
	PORTD|=(1<<PD3);	//зажигаем точку семисегментного индикатора
	ADMUX=0xC0;		//при инициализации АЦП выбираем опорное напряжение 2.56 В,
//правое выравнивание результата, и канал АDC0
	ADCSRA=0xD2;		//первый запуск АЦП без разрешения прерываний и с тактовой 
				//частотой 250 кГц
	unsigned int k_trans;	//коэффициент преобразования показаний АЦП в В;
	k_trans=K_V_R_256;		//присваиваем значение коэффициенту преобразования в 
					//соответствии с установками АЦП;	
int	ResADC;		//введенные данные с ADC					
	
    while(1)
    {
       if (ADCSRA &(1<<ADIF)) 
	{//закончилось очередное преобразование АЦП
		ResADC=ADC;
		PORTB=PrintBCD99(ResADC/k_trans);
		if(PIND & (1<<PD2))
		{//тумблер SA2 в состоянии логической "1" (левое выравнивание результата)
			if(PIND & (1<<PD1))
			{//тумблер SA3 в "1" (опорное напряжение 2.56 В)
				ADMUX=0xE0;         //задаем выбранный режим AЦП
				k_trans=K_V_L_256;	   									 }
			else
			{//тумблер SA3 в "0" (опорное напряжение 5 В)
				ADMUX=0x60;		//задаем выбранный режим АЦП
				k_trans=K_V_L_500;
			}	 
		}
		else
		{//тумблер SA2 в состоянии логического "0" (правое выравнивание результата)
			if(PIND & (1<<PD1))
			{//тумблер SA3 в "1" (опорное напряжение 2.56 В)
				ADMUX=0xC0; 		//задаем выбранный режим AЦП
				k_trans=K_V_R_256;	
			}
			else
			{//тумблер SA3 в "0" (опорное напряжение 5 В)
				ADMUX=0x40;		//задаем выбранный режим АЦП 
				k_trans=K_V_R_500;
			}
		}
		ADCSRA=0xD2;		//запускаем следующее преобразование АЦП
	}
			
    }
}
```

Листинг 4.2. Программирование АЦП при вводе данных дифференциального сигнала

```C
/* Exp_4 "Программирование АЦП микроконтроллера"
 * Exp_4_2 "Программирование АЦП при вводе данных дифференциального сигнала" 
 * АЦП программируется для ввода данных по каналу ADC4:ADC1 (выводы PF4:PF1)
 * c резистора 1 кОм миниблока A7, выполняющего роль нагрузочного резистора схемы.
 *  Регулирование напряжения на резисторе осуществляет потенциометр миниблока А5.
 * Микроконтроллер пересчитывает полученный результат в Вольты и выводит полученный 
 * результат на семисегментные индикаторы. Мультиметр позволяет судить о правильности 
 * полученного результата.
 * Красный светодиод индикатора логических уровней блока БИЦУ А1 показывает 
 * отрицательный знак числа
 */ 

#include <avr/io.h>

#define K_V_R_500 	655	//коэффициент приведения результата к В*10  при правом
//выравнивании и опорном напряжении 5 В	(напряжение питания)	

//программа преобразует число к двоично-десятичному числу, упакованному в один байт
//n – преобразуемое число (в диапазоне от 0…99
//выход: двоично-десятичное число
unsigned char PrintBCD99(unsigned char n)
{
	unsigned char nl;			//младшая тетрада двоично-десятичного числа
	nl=n%10;
	n=n/10;
	n=(n<<4)+nl;
	return n;
}

int main(void)
{
	DDRB=0xff;		//выводы управления семисегментным индикатором работают на выход
	DDRD|=(1<<PD3)+(1<<PD0);	//выход управления точкой семисегментного индикатора и 
					//светодиодом  индикатора логических уровней блока БИЦУ
	PORTD|=(1<<PD3);		//зажигаем точку семисегментного индикатора
	ADMUX=0x74;			//при инициализации АЦП выбираем опорное напряжение равное 
					//напряжению питания (~5В), левое выравнивание результата, 
//и канал АDC4:ADC1 c коэффициентом усиления 1
	ADCSRA=0xD2;			//первый запуск АЦП без разрешения прерываний и с тактовой
//частотой 250 кГц
	int k_trans;			//коэффициент преобразования показаний АЦП в В;
	k_trans=K_V_R_500;		//присваиваем значение коэффициенту преобразования в
//соответствии с установками АЦП;	
	int	ResADC;		//введенные данные с ADC	
	while(1)
    	{
        	if (ADCSRA &(1<<ADIF))
		{//закончилось очередное преобразование АЦП
			 ResADC=ADC;
			 if(ResADC<0)
			 {//отрицательное число
ResADC=-ResADC;			//меняем знак числа
PORTD|=(1<<PD0);			//зажигаем красный светодиод, имитирующий знак минус
			 }
			 else
			 {
PORTD&=~(1<<PD0);			//тушим красный светодиод 
			 }
			 PORTB=PrintBCD99(ResADC/k_trans);
			 ADCSRA=0xD2;	 //запускаем следующее преобразование АЦП
			 for(unsigned int i=0; i<5000;i++) ;	//цикл имитирующий основную 
									//часть программы
		}
    }
}
```

Листинг 4.3. Программирование АЦП с использованием предварительного усилителя сигнала

```C
/* Exp_4 "Программирование АЦП микроконтроллера"
 * Exp_4_3 "Программирование АЦП с использованием предварительного усилителя сигнала" 
 * АЦП программируется для ввода данных по каналу ADC1:ADC0 (выводы PF1:PF0)
 * c резистора 10 Ом миниблока A6, выполняющего роль шунта. Регулирование тока шунта 
 * производится потенциометр миниблока А5. Микроконтроллер пересчитывает полученный 
 * результат в мB и   выводит полученный  результат на семисегментные индикаторы. Мультиметр
 * позволяет судить о правильности  полученного результата.
 * Тумблер SA2 блока БИЦУ А! переключает величину опорного напряжения:
 * "0" - опорное напряжение равно напряжению питания микроконтроллера  (+5 В)
 * "1" - опорное напряжение равно внутреннему опорному напряжению 2.56. В
 * Тумблер SA3 блока БИЦУ А! переключает величину коэффициента усиления:
 * "0" - коэффициент усиления 10;
 * "1" - коэффициент усиления 40.
  */ 
#include <avr/io.h>
#include "Exp_4_3.h"
#define K_V_10_500 	1		//коэффициент приведения результата к мВ при коэффициенте
					// усиления 10 и опорном напряжении	+5 В
#define K_V_40_500 	4		//коэффициент приведения результата к мВ при коэффициенте
					// усиления 40 и опорном напряжении	+5 В		
#define K_V_10_256  2		//коэффициент приведения результата к мВ при коэффициенте
					// усиления 10 и опорном напряжении	+2.56 В
#define K_V_40_256 	8		//коэффициент приведения результата к мВ при коэффициенте
					// усиления 40 и опорном напряжении	+2.56 В 	

//программа преобразует число к двоично-десятичному числу, упакованному в один байт
//n – преобразуемое число (в диапазоне от 0…99
//выход: двоично-десятичное число
unsigned char PrintBCD99(unsigned char n)
{
	unsigned char nl;			//младшая тетрада двоично-десятичного числа
	nl=n%10;
	n=n/10;
	n=(n<<4)+nl;
	return n;
}

int main(void)
{
	DDRB=0xff;			//выводы управления семисегментным индикатором работают на
//выход
	DDRD|=(1<<PD3);		//выход управления точкой семисегментного индикатора
	ADMUX=0xC9;			//при инициализации АЦП выбираем опорное напряжение 
//2.56 В, и коэффициент усиления 10
	ADCSRA=0xD2;			//первый запуск АЦП без разрешения прерываний и с тактовой
//частотой 250 кГц
	unsigned int k_trans;	//коэффициент преобразования показаний АЦП в В;
	k_trans=K_V_10_256;		//присваиваем значение коэффициенту преобразования в
//соответствии с установками АЦП;
	int	ResADC;		//введенные данные с ADC
	while(1)
	{
		if (ADCSRA &(1<<ADIF))
		{//закончилось очередное преобразование АЦП
			ResADC=ADC;
			PORTB=PrintBCD99(ResADC/k_trans);
			if(PIND & (1<<PD2))
			{//тумблер SA2 в состоянии логической "1" (опорное напряжение 2.56 В)
				if(PIND & (1<<PD1))
				{//тумблер SA3 в "1" (коэффициент усиления 40)
					ADMUX=0xC6;          //задаем выбранный режим AЦП
					ADCSRB=0x20;
					k_trans=K_V_40_256;
				}
				else
				{//тумблер SA3 в "0" (коэффициент усиления 10)
					ADMUX=0xC9;		//задаем выбранный режим АЦП
					ADCSRB=0;
					k_trans=K_V_10_256;
				}
			}
			else
			{//тумблер SA2 в состоянии логического "0" (опорное напряжение 5В)
				if(PIND & (1<<PD1))
				{//тумблер SA3 в "1" (коэффициент усиления 40)
					ADMUX=0x46;		//задаем выбранный режим AЦП
					ADCSRB=0x20;
					k_trans=K_V_40_500;
					
				}
				else
				{//тумблер SA3 в "0" (коэффициент усиления 10)
					ADMUX=0x49;		//задаем выбранный режим АЦП
					ADCSRB=0;
					k_trans=K_V_10_500;
				}
			}
			ADCSRA=0xD2;			//запускаем следующее преобразование АЦП
			for(unsigned int i=0;i<50000;i++) ; //цикл, имитирующий основную 
								  //программу
		}
	}
}
```

## Задания для самостоятельной работы

## Содержание отчета

1. Титульный лист
2. Цель, задание на лабораторную работу
3. Электрическая схема
4. Алгоритм работы
5. Заключение
6. Приложения

## Контрольные вопросы

